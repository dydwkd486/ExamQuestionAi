[
    {
        "id": 1,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "프롬프트 엔지니어링의 정의와 최근 변화에 대한 설명으로 가장 적절하지 않은 것은?",
        "options": [
            "1. 언어 모델에서 원하는 결과를 얻기 위해 맥락(Context)을 설계하는 기술이다.",
            "2. 모델이 고도화됨에 따라 프롬프트 작성 기술은 점점 복잡하고 길어지는 추세이다.",
            "3. 메타 프롬프팅(Meta Prompting)의 성능 향상으로 프롬프트가 단순화되고 있다.",
            "4. 프롬프트 엔지니어링은 특정 직무를 넘어 누구나 갖춰야 할 역량으로 변화하고 있다.",
            "5. 주어진 Input에 대해 높은 확률의 다음 토큰을 출력하도록 유도하는 기술이다."
        ],
        "correctAnswer": "2",
        "explanation": "학습 내용에 따르면 모델의 고도화와 메타 프롬프팅 성능 향상으로 인해 프롬프트는 오히려 단순화되는 경향이 있습니다."
    },
    {
        "id": 2,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "효과적인 프롬프트 구성을 위한 요소(Framework) 중, 최근 그 중요도나 역할이 줄어들고 있다고 언급된 요소는?",
        "options": [
            "1. Task (작업 내용)",
            "2. Context (참고 정보)",
            "3. Format (출력 형식)",
            "4. Persona (페르소나)",
            "5. Constraint (제약 조건)"
        ],
        "correctAnswer": "4",
        "explanation": "과거에는 전문가 역할을 부여하는 페르소나(Persona)가 효과적이었으나, 최근에는 비직관적인 요소로 간주되어 성능 향상에 큰 도움이 되지 않으며 역할 정보 형식을 제대로 입력하는 것이 더 중요해지고 있습니다."
    },
    {
        "id": 3,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "Prompt Chaining(프롬프트 체이닝)의 장점으로 올바르지 않은 것은?",
        "options": [
            "1. 복잡한 작업을 여러 단계로 나누어 처리할 수 있다.",
            "2. 불필요한 정보를 제거하여 Context 길이를 단축시킨다.",
            "3. 한 번의 거대한 프롬프트로 처리하는 것보다 토큰 소모를 절감할 수 있다.",
            "4. LLM이 이전 맥락을 기억하지 못하게 하여 독립적인 답변을 얻는다.",
            "5. 사용 효율성을 향상시킨다."
        ],
        "correctAnswer": "4",
        "explanation": "Prompt Chaining을 하더라도 LLM은 이전 맥락을 기억하며 이를 활용하여 다음 작업을 수행합니다. 체이닝의 목적은 질문을 쪼개 효율성을 높이는 데 있습니다."
    },
    {
        "id": 4,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "프롬프트 구조화 기법 중, LLM이 집중해야 할 부분을 강조하기 위해 사용하는 방법으로 적절한 것은?",
        "options": [
            "1. 모든 텍스트를 대문자로 작성한다.",
            "2. #, ---, [], <> 등의 구분 기호를 사용하여 요소를 명확히 분리한다.",
            "3. 같은 단어를 10번 이상 반복한다.",
            "4. 문장의 순서를 무작위로 섞어서 입력한다.",
            "5. JSON 형식이 아닌 줄글로만 작성한다."
        ],
        "correctAnswer": "2",
        "explanation": "프롬프트 구조화에서는 구분 기호(Delimiters)를 사용하여 지시사항, 데이터, 출력 형식 등을 명확하게 분리하는 것이 LLM의 이해를 돕습니다."
    },
    {
        "id": 5,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "Few-shot Prompting 사용 시 주의해야 할 점으로 가장 적절한 것은?",
        "options": [
            "1. 예시를 제공하면 모델의 처리 속도가 느려진다.",
            "2. 예시의 길이, 톤, 주제 등에 의해 결과가 편향(Bias)될 수 있다.",
            "3. 예시는 반드시 10개 이상 제공해야 한다.",
            "4. 한글 예시를 주면 영어로 답변할 수 없다.",
            "5. 구조화된 출력에는 사용할 수 없다."
        ],
        "correctAnswer": "2",
        "explanation": "Few-shot 프롬프팅은 예시에 몰입된 결과로 인해 특정 방향으로 과도하게 영향을 받거나 편향이 생길 수 있다는 주의점이 있습니다."
    },
    {
        "id": 6,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "LangChain의 LCEL(LangChain Expression Language)에서 'Runnable'에 대한 설명으로 틀린 것은?",
        "options": [
            "1. 입력을 받아 출력을 생성하는 LangChain의 기본 단위이다.",
            "2. Prompt, LLM, Parser 등이 모두 Runnable에 해당한다.",
            "3. 파이프(|) 연산자를 사용하여 체인으로 연결할 수 있다.",
            "4. RunnablePassthrough는 직전 단계의 출력을 무시하고 새로운 입력을 생성한다.",
            "5. RunnableSequence를 통해 LangChain을 구성한다."
        ],
        "correctAnswer": "4",
        "explanation": "RunnablePassthrough는 직전 Runnable의 출력을 '그대로 전달'하는 역할을 하며, RAG 등에서 중요한 역할을 합니다."
    },
    {
        "id": 7,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "LCEL의 특수한 Runnable 중, 1개 이상의 Runnable을 병렬로 실행하고 그 결과를 Dictionary 형태로 저장하는 것은?",
        "options": [
            "1. RunnablePassthrough",
            "2. RunnableParallel",
            "3. RunnableSequence",
            "4. RunnableLambda",
            "5. RunnableBranch"
        ],
        "correctAnswer": "2",
        "explanation": "RunnableParallel은 여러 작업을 병렬로 수행하고 결과를 맵(Dict) 형태로 반환하여, 이후 단계에서 데이터를 결합하거나 활용할 수 있게 합니다."
    },
    {
        "id": 8,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "Chain-of-Thought(CoT) 기법의 핵심적인 특징은?",
        "options": [
            "1. 질문에 대해 즉시 정답만 출력하게 한다.",
            "2. 예시를 전혀 제공하지 않고 추론하게 한다.",
            "3. 풀이 과정(논리적 추론)을 함께 출력하여 복잡한 문제 해결 능력을 높인다.",
            "4. 검색 엔진을 사용하여 최신 정보를 찾아낸다.",
            "5. 모델의 창의성을 극대화하여 소설을 쓰게 한다."
        ],
        "correctAnswer": "3",
        "explanation": "CoT는 질문에 바로 답하지 않고, 단계적인 풀이 과정을 생성하도록 유도하여 논리적 추론 성능을 향상시키는 기법입니다."
    },
    {
        "id": 9,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "Step-Back Prompting에 대한 설명으로 가장 적절한 것은?",
        "options": [
            "1. 문제를 가장 작은 단위로 쪼개서 하나씩 해결하는 방식이다.",
            "2. 답변 생성 전, 필요한 요소와 큰 구조(개념)를 먼저 도출하여 정확성을 높이는 기법이다.",
            "3. 이전 대화 내용을 모두 삭제하고 다시 시작하는 기법이다.",
            "4. 모델에게 반성(Reflection)을 강요하여 답변을 수정하게 한다.",
            "5. 외부 도구(Tool)를 사용하여 답변을 검증한다."
        ],
        "correctAnswer": "2",
        "explanation": "Step-Back Prompting은 LLM이 세부 사항에 매몰되지 않고 전체 구조나 필요한 개념을 먼저 파악('한 발 물러서서 보기')한 뒤 답변을 생성하도록 유도하는 기법입니다."
    },
    {
        "id": 10,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "프롬프트 작성 시 '영어 지시'를 사용할 때의 장점이 아닌 것은?",
        "options": [
            "1. 대부분의 모델이 영어 학습량이 압도적으로 많아 안정적인 결과를 제공한다.",
            "2. 동일한 내용 작성 시 한글보다 토큰 수가 적어 비용이 절감된다.",
            "3. 복잡한 지시 사항을 모델이 더 정확하게 이해할 수 있다.",
            "4. 한국 문화에 특화된 뉘앙스를 가장 잘 표현할 수 있다.",
            "5. 처리 속도가 향상된다."
        ],
        "correctAnswer": "4",
        "explanation": "영어 지시는 모델의 이해도와 비용/속도 면에서 유리하지만, 한국 고유의 문화나 뉘앙스, 전문 지식이 필요한 경우에는 한국어 성능이 더 중요할 수 있습니다."
    },
    {
        "id": 11,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "문서 요약 기법 중 'Refine' 방식이 가장 적절한 경우는?",
        "options": [
            "1. 문서가 매우 짧아 한 번에 처리가 가능한 경우",
            "2. 모든 청크를 병렬로 처리하여 속도를 높여야 하는 경우",
            "3. 시간 순서로 정리되어 있거나 앞뒤 맥락이 이어지는 문서인 경우",
            "4. 토큰 비용을 최소화해야 하는 경우",
            "5. 서로 관련 없는 뉴스 기사들을 각각 요약할 경우"
        ],
        "correctAnswer": "3",
        "explanation": "Refine 방식은 앞 청크의 요약 결과에 새 청크 내용을 덧붙여 갱신하는 순차적 방식이므로, 시간 순서나 맥락이 이어지는 문서에 적합합니다. 단, 토큰 소모가 큽니다."
    },
    {
        "id": 12,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "문서 요약 방식 중 전체 문서를 청크로 나누어 각각 요약한 뒤, 그 요약본들을 합쳐 최종 요약을 만드는 방식은?",
        "options": [
            "1. Stuff",
            "2. Map-Reduce",
            "3. Refine",
            "4. ReAct",
            "5. Zero-shot"
        ],
        "correctAnswer": "2",
        "explanation": "Map-Reduce는 'Map' 단계에서 각 청크를 요약하고, 'Reduce' 단계에서 요약된 내용들을 합쳐 최종 결과물을 만드는 방식입니다."
    },
    {
        "id": 13,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "LLM의 한계를 극복하기 위한 3요소에 해당하지 않는 것은?",
        "options": [
            "1. Retrieval (검색)",
            "2. Tools (도구)",
            "3. Memory (기억)",
            "4. Parsing (구문 분석)",
            "5. RAG (검색 증강 생성)"
        ],
        "correctAnswer": "4",
        "explanation": "학습 내용에서 LLM의 한계 극복 3요소는 Retrieval, Tools, Memory로 정의되어 있습니다. Parsing은 출력 변환 도구입니다."
    },
    {
        "id": 14,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "Tool Calling 메커니즘에서 LLM의 역할 변화에 대한 설명으로 옳은 것은?",
        "options": [
            "1. Tasker에서 Giver로 변화하여 실제 행동과 제어가 가능해졌다.",
            "2. 과거에는 Giver였으나 현재는 단순히 정보만 주는 Tasker로 변했다.",
            "3. Tool Calling을 사용하면 LLM은 더 이상 텍스트를 생성하지 않는다.",
            "4. Fine Tuning 없이 모든 모델이 Tool Calling을 완벽하게 수행한다.",
            "5. LLM은 오직 읽기(Read) 권한만 가진다."
        ],
        "correctAnswer": "1",
        "explanation": "LLM은 단순히 정보를 전달하는 'Tasker'에서, 외부 툴을 실행하고 상황을 제어하는 주체적인 'Giver'로 역할이 확장되었습니다."
    },
    {
        "id": 15,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "LangChain Agent의 'ReAct' 기법의 3단계 구성 요소로 올바른 것은?",
        "options": [
            "1. Input - Process - Output",
            "2. Thinking(생각) - Action(행동) - Observation(관찰)",
            "3. Plan - Do - Check",
            "4. Retrieval - Generation - Ranking",
            "5. Prompt - LLM - Parser"
        ],
        "correctAnswer": "2",
        "explanation": "ReAct(Reasoning + Acting)는 생각(Thinking)을 통해 계획을 세우고, 행동(Action)으로 도구를 사용하며, 그 결과인 관찰(Observation)을 통해 다음 단계를 결정합니다."
    },
    {
        "id": 16,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "ReAct와 비교하여 'ReFlexion' 기법의 가장 큰 차이점은?",
        "options": [
            "1. 도구를 전혀 사용하지 않는다.",
            "2. 실패 원인을 분석하고 반성(Self-reflection)하여 다음 실행에 반영한다.",
            "3. 한 번의 시도만으로 완벽한 답을 낸다.",
            "4. 사람의 개입이 필수적이다.",
            "5. 검색 엔진만 사용한다."
        ],
        "correctAnswer": "2",
        "explanation": "ReFlexion은 단순한 단계적 실행을 넘어, 결과에 대한 피드백을 기반으로 자기 반성 과정을 거쳐 오류를 수정하고 개선하는 것이 특징입니다."
    },
    {
        "id": 17,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "Agent를 완전히 자율화시키는 것보다 효율적인 방식으로, 정해진 흐름(Workflow) 안에서 선택적으로 LLM을 활용하는 2025년의 트렌드 용어는?",
        "options": [
            "1. Fully Autonomous Agent",
            "2. Agentic Work",
            "3. Hard Coded Bot",
            "4. Simple Chain",
            "5. Zero-shot Agent"
        ],
        "correctAnswer": "2",
        "explanation": "2025년 트렌드로는 Agent와 Agentic Work가 분리되며, Agentic Work는 워크플로우 내에서 LLM의 판단을 선택적으로 활용하는 방식을 말합니다."
    },
    {
        "id": 18,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "Multi Agent 시스템을 구축할 때 얻을 수 있는 장점으로 가장 적절한 것은?",
        "options": [
            "1. 시스템 구성이 매우 단순해진다.",
            "2. 하나의 거대한 LLM을 쓰는 것보다 토큰 낭비를 감소시키고 전문성을 높일 수 있다.",
            "3. 에러 발생 시 원인 파악이 불가능해진다.",
            "4. 모든 에이전트가 동일한 프롬프트를 공유한다.",
            "5. 속도가 무조건 느려진다."
        ],
        "correctAnswer": "2",
        "explanation": "역할(검색, 개발, 작성 등)을 분리한 여러 에이전트를 사용하면 각 작업에 최적화된 처리가 가능하여 토큰 효율성이 높아지고 전문적인 수행이 가능합니다."
    },
    {
        "id": 19,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "다음 중 RAG(검색 증강 생성)에 대한 설명으로 옳은 것은?",
        "options": [
            "1. LLM의 학습 데이터에만 의존하여 답변한다.",
            "2. 검색 결과를 Context로 제공하여 할루시네이션(환각)을 완화한다.",
            "3. 외부 정보를 차단하여 보안을 강화하는 기술이다.",
            "4. 텍스트 요약에만 사용되는 기술이다.",
            "5. 프롬프트 길이를 줄이기 위한 기술이다."
        ],
        "correctAnswer": "2",
        "explanation": "RAG는 Retrieval Augmented Generation의 약자로, 외부 정보를 검색하여 프롬프트의 Context로 제공함으로써 최신 정보 부재나 할루시네이션 문제를 완화합니다."
    },
    {
        "id": 20,
        "chapter": "4. 프롬프트 엔지니어링",
        "question": "Zero-shot-CoT(Zero-shot Chain of Thought)를 유도하기 위해 프롬프트에 추가하는 문구는?",
        "options": [
            "1. \"이것을 요약해줘\"",
            "2. \"예시를 들어서 설명해줘\"",
            "3. \"단계별로 생각해봐(Let's think step by step)\"",
            "4. \"전문가처럼 행동해\"",
            "5. \"JSON으로 출력해\""
        ],
        "correctAnswer": "3",
        "explanation": "별도의 예시(Few-shot) 없이 논리적 추론을 유도하기 위해 \"Let's think step by step(단계별로 생각해봐)\" 같은 문구를 사용하는 것을 Zero-shot-CoT라고 합니다."
    }
]